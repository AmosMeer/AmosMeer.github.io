<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【DP】 Codeforces Round 536 (Div. 2) E. Lunar New Year and Red Envelopes]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[题目地址：https://codeforces.com/contest/1106/problem/E Lunar New Year is approaching, and Bob is going to receive some red envelopes with countless money! But collecting money from red envelopes is a time-consuming process itself.Let’s describe this problem in a mathematical way. Consider a timeline from time 1 to n. The i-th red envelope will be available from time si to ti, inclusive, and contain wi coins. If Bob chooses to collect the coins in the i-th red envelope, he can do it only in an integer point of time between si and ti, inclusive, and he can’t collect any more envelopes until time di (inclusive) after that. Here si≤ti≤di holds.Bob is a greedy man, he collects coins greedily — whenever he can collect coins at some integer time x, he collects the available red envelope with the maximum number of coins. If there are multiple envelopes with the same maximum number of coins, Bob would choose the one whose parameter d is the largest. If there are still multiple choices, Bob will choose one from them randomly.However, Alice — his daughter — doesn’t want her father to get too many coins. She could disturb Bob at no more than m integer time moments. If Alice decides to disturb Bob at time x, he could not do anything at time x and resumes his usual strategy at the time x+1 (inclusive), which may lead to missing some red envelopes.Calculate the minimum number of coins Bob would get if Alice disturbs him optimally. Description在时间线为 1~n 上有 k 个信封和 m 个干扰机会，每个信封有领取时间段 [s, t]、时间点 d（领了个这个信封之后，在 d 点前无法领取其他信封）、以及价值 w，对于每个干扰机会，可以使其在任意一个时间点无法进行领取操作直到x+1。问最优使用不超过m次干扰下，将领取的最小信封价值总和。每次领取的策略是取当前可领取信封中 w 最大的，w 相同时取 d 最大的。 Solutiondp[i][j] 表示前 i 个时间点中用了 j 次机会所能得到的最少金币。 由于Bob每次要优先取 wi 最大，其次是取 di 最大，所以利用优先队列，在当前 i 这个时间点，将所有满足条件的信封放入优先队列，然后再进行转移。 对于每个时间点 i，如果当前没有满足条件的信封即优先队列为空时，就要把当前时间点的状态保留至下一个时间点。 $for(int j = 0; j &lt;= m; j++) dp[i+1][j] = Min(dp[i+1][j], dp[i][j]);$ 如果有可用的信封，那么对于每次干扰机会 j，都有选择干扰和不干扰两种操作。 如果不干扰：$dp[di+1][j] = min(dp[di+1][j], dp[i][j] + wi);$ 如果干扰：$dp[i+1][j+1] = min(dp[i+1][j+1], dp[i][j])$（注意此时 j 必须小与 m） Code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#pragma GCC diagnostic error "-std=c++11"#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;map&gt;#define fi first#define se second#define mst(a, b) memset(a, b, sizeof(a))using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF = 0x3f3f3f3f;const double eps = 1e-9;const int Mod = 1e9 + 7;const int MaxN = 1e5 + 5;struct node &#123; int s, t, d, w; bool operator &lt; (const node&amp; q) const &#123; if(q.w == w) return q.d &gt; d; return q.w &gt; w; &#125;&#125;a[MaxN];;priority_queue&lt;node&gt; q;LL dp[MaxN][205];bool cmp(node x, node y) &#123; return x.s &lt; y.s; &#125;LL Min(LL x, LL y) &#123; if(y == -1) return x; if(x == -1) return y; return min(x, y);&#125;int main()&#123; int n, m, k; scanf("%d %d %d", &amp;n, &amp;m, &amp;k); for(int i = 1; i &lt;= k; i++) &#123; scanf("%d %d %d %d", &amp;a[i].s, &amp;a[i].t, &amp;a[i].d, &amp;a[i].w); &#125; sort(a + 1, a + 1 + k, cmp); memset(dp, -1, sizeof(dp)); dp[1][0] = 0; int num = 1; for(int i = 1; i &lt;= n; i++) &#123; while(num &lt;= k &amp;&amp; a[num].s &lt;= i) q.push(a[num++]); // 选取合法信封 while(!q.empty() &amp;&amp; q.top().t &lt; i) q.pop(); // 排除不合法信封 if(q.empty()) &#123; // 如果当前时间点没有可选信封，那么当前状态就保留至下一个时间点 for(int j = 0; j &lt;= m; j++) dp[i+1][j] = Min(dp[i+1][j], dp[i][j]); &#125; else &#123; node now = q.top(); for(int j = 0; j &lt;= m; j++) &#123; if(dp[i][j] == -1) continue; dp[now.d+1][j] = Min(dp[now.d+1][j], dp[i][j]+now.w); // 不干扰此次操作 if(j &lt; m) &#123; // 干扰此次操作 dp[i+1][j+1] = Min(dp[i+1][j+1], dp[i][j]); &#125; &#125; &#125; &#125; LL ans = 1e18; for(int i = 0; i &lt;= m; i++) ans = min(ans, dp[n+1][i]); ans = max(0LL, ans); // 注意ans可能为负 printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>DP</category>
      </categories>
      <tags>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【DFS、期望】 Codeforces Round 428 (Div. 2) C. Journey]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[题目链接：https://codeforces.com/contest/839/problem/CC. JourneyThere are n cities and n - 1 roads in the Seven Kingdoms, each road connects two cities and we can reach any city from any other by the roads.Theon and Yara Greyjoy are on a horse in the first city, they are starting traveling through the roads. But the weather is foggy, so they can’t see where the horse brings them. When the horse reaches a city (including the first one), it goes to one of the cities connected to the current city. But it is a strange horse, it only goes to cities in which they weren’t before. In each such city, the horse goes with equal probabilities and it stops when there are no such cities.Let the length of each road be 1. The journey starts in the city 1. What is the expected length (expected value of length) of their journey? You can read about expected (average) value by the link https://en.wikipedia.org/wiki/Expected_value. InputThe first line contains a single integer n (1 ≤ n ≤ 100000) — number of cities.Then n - 1 lines follow. The i-th line of these lines contains two integers ui and vi (1 ≤ ui, vi ≤ n, ui ≠ vi) — the cities connected by the i-th road.It is guaranteed that one can reach any city from any other by the roads. OutputPrint a number — the expected length of their journey. The journey starts in the city 1.Your answer will be considered correct if its absolute or relative error does not exceed 10 - 6. Description由 n 个顶点 n-1 条边构成的以 1 为根的树，从根出发，等概率的往其子树走，求走过的路径长度的期望。 SolutionDFS.例如：对5、6、7号结点期望求和即可。 需要注意的是，除了 1 号结点之外，其余结点均有父节点，所以在求其子树时需要减一，减去父节点，即：G[x].size()-1。 Code12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#pragma GCC diagnostic error "-std=c++11"#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;set&gt;#include &lt;map&gt;#define fi first#define se second#define mst(a, b) memset(a, b, sizeof(a))using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int INF = 0x3f3f3f3f;const double eps = 1e-9;const int Mod = 1e9 + 7;const int MaxN = 1e5 + 5;vector&lt;int&gt; G[MaxN];int vis[MaxN];int n;double DFS(int x) &#123; vis[x] = 1; double sum = 0.0; for(int i = 0; i &lt; G[x].size(); i++) &#123; int u = G[x][i]; if(!vis[u]) &#123; sum += DFS(u) + 1; &#125; &#125; int p = G[x].size() - (x != 1); return p ? (sum / p) : 0;&#125;int main()&#123; //ios::sync_with_stdio(false); cin.tie(0); cout.tie(0); scanf("%d", &amp;n); for(int i = 1; i &lt; n; i++) &#123; int u, v; scanf("%d %d", &amp;u, &amp;v); G[u].push_back(v); G[v].push_back(u); &#125; printf("%.6lf\n", DFS(1)); return 0;&#125;]]></content>
      <categories>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
        <tag>期望</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Github Pages 和 Hexo 搭建博客常见问题解决]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[欢迎各位大佬来参观我的博客：AmosMeer’s Blog搭建过程中出现的任何问题请参考博客：常见问题解决完整的博客搭建过程的文章汇总： 利用 Github Pages 和 Hexo 初步搭建博客 博客的美化配置（NexT主题） 博客的功能配置 利用 Github Pages 和 Hexo 搭建博客常见问题解决 常见 Hexo 命令 常见问题说明：hexo 下的 _config.yml 称为站点配置文件themes/next 中 的_config.yml 称为主题配置文件 语言不生效问题根据官方文档描述：| 语言 | 代码 | 设定示例 ||–|–|–|| English | en | language: en ||简体中文 | zh-Hans | language: zh-Hans||Français| fr-FR | language: fr-FR||Português| pt| language: pt or language: pt-BR||繁體中文| zh-hk 或者 zh-tw| language: zh-hk||Русский| язык |ru language: ru||Deutsch| de |language: de||日本語| ja| language: ja||Indonesian| id |language: id||Korean| ko |language: ko| 在站点配置文件中设置语言 language: zh-Hans // 这里设置语言为 简体中文 如果不起作用的话，查看 themes/next/languages/ 目录下是否有zh-Hans.yml 文件。如果没有的话需要把 zh-CN.yml 文件改成名字为 zh-Hans.yml 就可以了。 出现 npm: command not found有 git bash，也安装了 node.js, 但是在运行 bash 时依旧会报错 npm: command not found解决方案：需要改成全局安装。npm install grunt ：本地安装npm install -g grunt-cli ：全局安装在cmd 下输入以下内容就可以了： npm install -g grunt-cli 创建新的SSH密钥时创建失败解决方案：如果创建位置位于C盘，可以尝试以管理员的身份运行 Git Bash Here 出现 bash: cd: too many arguments命令中存在空格，如果是不必要空格直接删掉就好，若果是路径名或者变量中间有空格时，需要用双引号括起来。 Git 密钥认证 github 时出现错误 $ ssh -T git@github.comThe authenticity of host ‘github.com (192.30.255.112)’ can’t be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKY8.Are you sure you want to continue connecting (yes/no)? 解决方案：直接输入 yes 回车，这时在ssh目录下除 id_rsa，id_rsa.pub 文件外，还会生成一个know_hosts 文件。 出现 ERROR Deployer not found: git执行 hexo g -d 时出现报错 ERROR Deployer not found: git，说明你的 deployer 没有安装成功，需要执行如下命令再安装一次： npm install hexo-deployer-git –save 这样，再执行 hexo g -d，博客就部署到 Github 上了 hexo更换主题后出现 WARN No layout: index.html解决方案： 检查下载的主题是不是放在了 themes 文件夹下面。比如 next 主题的放置，就是点开 themes 就看到 next 的文件夹，next 下面就是主题的文件，不能打开 next 文件夹里面还有 themes。 检查站点配置 _config.yml 是否正确：theme: 主题名字 这里是 theme，不是themes theme 与主题名直接有一个空格（冒号后面有空格） 主题名字是否与themes文件夹下的主题的名字一致 乱码问题如果是记事本编辑后出现了乱码，尝试使用另存为更换编码方式为 utf-8 git错误:unable to auto-detect email address每次重新新建工程时候git的配置信息都不能直接在命令行里修改 用户名 和邮箱，不会生效，且报错 *** Please tell me who you are.Rungit config –global user.email “you@example.com“git config –global user.name “Your Name”to set your account’s default identity.Omit –global to set the identity only in this repository.fatal: unable to auto-detect email address (got ‘Administrator@PC-20150120BUBR.(none)’) 解决方案：找到工程目录 (Project) 的.git文件夹 Hexo\.deploy_git\.git，打开之后找到 config 文件，在最后边加上一句话[user]email=your emailname=your name]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的功能配置]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[欢迎各位大佬来参观我的博客：AmosMeer’s Blog搭建过程中出现的任何问题请参考博客：常见问题解决完整的博客搭建过程的文章汇总： 利用 Github Pages 和 Hexo 初步搭建博客 博客的美化配置（NexT主题） 博客的功能配置 利用 Github Pages 和 Hexo 搭建博客常见问题解决 常见 Hexo 命令 主要有以下功能配置： 添加「标签」页面 添加「分类」页面 添加「关于」页面 用hexo发表新文章 1.添加「标签」页面新建页面 hexo new page tags 修改站点目录下 source/tags 的 index.md 文件如下： --- title: tags type: &quot;tags&quot; comments: false --- 修改主题配置文件，取消 #tags: /tags 这行注释，内容如下 # 菜单示例配置 menu: home: / archives: /archives #about: /about #categories: /categories tags: /tags #commonweal: /404.html 新建测试文章，在新文章的头部添加tags信息，如下： title: 测试文章 tags: - Testing - Another Tag --- 2.添加「分类」页面新建页面 hexo new page categories 修改站点目录下 source/categories 的 index.md 文如下： 12345---title: categoriestype: &quot;categories&quot;comments: false--- 修改主题配置文件，取消 #categories: /categories 这行注释，内容如下 12345678# 菜单示例配置menu: home: / archives: /archives #about: /about categories: /categories tags: /tags #commonweal: /404.html 在刚才测试的文章里面添加 title: 测试文章 tags: - Testing - Another Tag categories: Testing --- 3.添加「关于」页面新建页面 hexo new page about 修改主题配置文件，取消 #about: /about 这行注释，内容如下 # 菜单示例配置 menu: home: / archives: /archives about: /about categories: /categories tags: /tags #commonweal: /404.html 编辑站点目录下 source/about 的 index.md 文件内容，内容将显示在关于页面。 4. 用hexo发表新文章$ hexo n &quot;文章标题&quot; 执行命令 hexo n &quot;test&quot; 后，会在项目 \Hexo\source_posts 中生成 我的家.md文件，用编辑器打开编写即可。 当然，也可以直接在\Hexo\source_posts中新建一个md文件，写完后，推送到服务器上，执行以下命令即可在我们的站点看到新的文章。 $ hexo g #生成 $ hexo d #部署 # 可与hexo g合并为 hexo d -g]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见Hexo命令]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[欢迎各位大佬来参观我的博客：AmosMeer’s Blog搭建过程中出现的任何问题请参考博客：常见问题解决完整的博客搭建过程的文章汇总： 利用 Github Pages 和 Hexo 初步搭建博客 博客的美化配置（NexT主题） 博客的功能配置 利用 Github Pages 和 Hexo 搭建博客常见问题解决 常见 Hexo 命令 查看官方文档 指令init1$ hexo init [folder] 新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。 new1$ hexo new [layout] == $ hexo n 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 generate1$ hexo generate == $ hexo g publish1$ hexo publish [layout] &lt;filename&gt; 发表草稿。 server1$ hexo server == $ hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/。 deploy1$ hexo deploy == $ hexo d 部署网站。 render1$ hexo render &lt;file1&gt; [file2] ... migrate1$ hexo migrate &lt;type&gt; 从其他博客系统 迁移内容。 clean1$ hexo clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。 在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 list1$ hexo list &lt;type&gt; 列出网站资料。 version1$ hexo version 显示 Hexo 版本。 选项安全模式 $ hexo –safe 在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。 调试模式 $ hexo –debug 在终端中显示调试信息并记录到 debug.log。当您碰到问题时，可以尝试用调试模式重新执行一次，并 提交调试信息到 GitHub。 简洁模式 $ hexo –silent 隐藏终端信息。 自定义配置文件的路径 $ hexo –config custom.yml 自定义配置文件的路径，执行后将不再使用 _config.yml。 显示草稿 $ hexo –draft 显示 source/_drafts 文件夹中的草稿文章。 自定义 CWD $ hexo –cwd /path/to/cwd 自定义当前工作目录（Current working directory）的路径。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Github Pages 和 Hexo 初步搭建博客]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[欢迎各位大佬来参观我的博客：AmosMeer’s Blog搭建过程中出现的任何问题请参考博客：常见问题解决完整的博客搭建过程的文章汇总： 利用 Github Pages 和 Hexo 初步搭建博客 博客的美化配置（NexT主题） 博客的功能配置 利用 Github Pages 和 Hexo 搭建博客常见问题解决 常见 Hexo 命令 关于GithubGithub的优点GitHub是基于git实现的代码托管。git可能是目前最好用的版本控制系统了，非常受欢迎。GitHub可以免费使用，并且快速稳定。Github上面的世界很精彩，用久了你的眼界会开阔很多。 Github PagesGithub Pages可以被认为是用户编写的、托管在github上的静态网页。 Github Pages可以绑定你的域名(但暂时好像只能绑定一个)。简单快捷，使用Github Pages可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。 环境准备1. 安装Node.js在 Windows 环境下安装 Node.js 非常简单，仅须到官网下载安装文件并执行即可完成安装。 2. 安装Git去Git官网根据你的电脑参数，下载对应版本。 下载完成，通过在命令行输入 git version 查看是否安装成功，有输出版本号说明安装成功。 鼠标右键的菜单里就多了 Git GUI Here 和 Git Bash Here 两个按钮，一个是图形界面的Git操作，一个是命令行，我们选择Git Bash Here。 HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 1. Hexo安装桌面右键鼠标，点击 Git Bash Here，输入 npm 命令即可安装 npm install hexo-cli -gnpm install hexo-deployer-git –save 第一句是安装hexo，第二句是安装hexo部署到git page的deployer，两个都需要安装。 2. 初始化配置创建Hexo文件夹安装完成后，根据自己喜好建立目录（如F:\Blog\Hexo），直接进入F:\Blog\Hexo文件夹下右键鼠标，点击Git Bash Here，进入Git命令框，执行以下操作。 $ hexo init 安装 Hexo 完成后，Hexo 将会在指定文件夹中新建所需要的文件。Hexo文件夹下的目录如下： 本地查看效果执行下面语句，执行完即可登录localhost:4000查看效果 hexo generatehexo server 登录localhost:4000，即可看到本地的效果如下： 将博客部署到Github Pages上一. 注册Github账户 访问Github首页 点击右上角的 Sign Up，注册自己的账户点击右上角的 Sign Up，注册自己的账户 二. 创建项目代码库 注册完登陆后，我们就创建一个我们自己的Github Pages项目。点击New repository。 创建要点如下： 三. 配置SSH密钥配置Github的SSH密钥可以让本地git项目与远程的github建立联系，让我们在本地写了代码之后直接通过git操作就可以实现本地代码库与Github代码库同步。操作如下： 看看是否存在SSH密钥(keys) $ cd ~/. ssh 检查你本机用户home目录下是否存在.ssh目录如果不存在此目录，则进行第二步操作，否则，你本机已经存在ssh公钥和私钥，可以略过第二步，直接进入第三步操作。 创建一对新的SSH密钥(keys) $ssh-keygen -t rsa -C “your_email@example.com“ #这将按照你提供的邮箱地址，创建一对密钥Generating public/private rsa key pair.Enter file in which to save the key (/c/Users/you/.ssh/id_rsa): [Press enter] 直接回车，则将密钥按默认文件进行存储。此时也可以输入特定的文件名，比如/c/Users/you/.ssh/github_rsa 接着，根据提示，你需要输入密码和确认密码，如果和我一样比较懒可以不设置密码，直接回车就好。。所谓的最安全的密码，就是没有密码哈哈哈 相关提示如下： Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 输入完成之后，屏幕会显示如下信息： Your identification has been saved in /c/Users/you/.ssh/id_rsa.Your public key has been saved in /c/Users/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 在GitHub账户中添加公钥运行如下命令，将公钥的内容复制到系统粘贴板(clipboard)中。 clip &lt; ~/.ssh/id_rsa.pub 然后：1. 登陆GitHub,进入你的Account Settings. 2. 选择SSH Keys 3. 粘贴密钥，添加即可4. 测试是否成功设置 $ ssh -T git@github.com 如果收到下面的反馈，直接输入 yes 就好 The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 5. 设置用户信息现在你已经可以通过SSH链接到GitHub了，但是还有一些个人信息需要完善。Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字根据自己的喜好自己取，而不是GitHub的昵称。 $ git config –global user.name “AmosMeer” //你的用户名$ git config –global user.email “amosmeer@gmail.com“ //你的邮箱 SSH Key配置成功 将本地的Hexo文件更新到Github的库中 登录Github打开自己的项目 username.github.io 打开之后，点击SSH，选择SSH类型地址并复制地址 打开你一开始创建的 Hexo 文件夹（如 F:\Blog\Hexo），用记事本打开刚文件夹下的 _config.yml 文件 在配置文件里作如下修改，保存 在Hexo文件夹下执行： hexo ghexo d 或者直接执行： hexo g -d 执行完之后会让你输入 github 的账号和密码，输入完后就可以部署在 Github Pages 服务器上的博客了。对应的地址是 username.github.io(我的是：AmosMeer.github.io)。 在浏览器上输入自己的主页地址在浏览器上输入Github Pager为我们生成的外链（例如我的是：AmosMeer.github.io/，而你的只需要把你的github用户名替换掉这个链接中的 AmosMeer）即可看到自己的博客了。当然，每一个人都可以通过这个地址访问到你的博客了。 到这为止，博客就初步搭建完成啦！ 关联域名到Github Pages配置CNAME文件在 \hexo\source 文件夹下创建文件 CNAME （新建记事本文件命名CNAME，然后打开）内容为你的域名，例如我的域名是：amosmeer.cn在Hexo文件夹提交 hexo g -d 修改DNS点击域名管理，修改DNS为（一般就是默认值）： f1g1ns2.dnspod.net f1g1ns1.dnspod.net 一般都会有引导，可以点击 “一键修改” 域名解析 点击 “域名解析” 点击 “添加记录” 记录类型选A，解析记录设置为@。A记录的记录值就是ip地址，github(官方文档)提供了两个IP地址，192.30.252.153 和 192.30.252.154，这两个IP地址为 github 的服务器地址，两个都要填上。再添加一条解析记录，记录类型选 CNAME，解析记录设置为www，线路默认就行。CNAME 记录值填你的github博客网址，例如我的是amosmeer.github.io。]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客的美化配置（NexT主题）]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[欢迎各位大佬来参观我的博客：AmosMeer’s Blog搭建过程中出现的任何问题请参考博客：常见问题解决完整的博客搭建过程的文章汇总： 利用 Github Pages 和 Hexo 初步搭建博客 博客的美化配置（NexT主题） 博客的功能配置 利用 Github Pages 和 Hexo 搭建博客常见问题解决 常见 Hexo 命令 主要有一下 23 种配置： 在右上角或者左上角实现 fork me on github 修改文章内链接文本样式 修改底部标签样式 在文章末尾添加“文章结束”标记 设置头像并设置动画效果 修改代码块自定义样式 侧边栏社交小图标设置 主页文章添加阴影效果 网站底部加访问量（待完成） 添加热度（待完成） 网站底部加上字数统计和阅读时长 设置网站的图标Favicon12 实现文章统计功能 添加网页顶部进度加载条 底部隐藏由Hexo强力驱动、主题–NexT.Mist 博文置顶 添加站内搜索 在文章底部增加版权信息 添加侧栏推荐阅读 添加底部桃心 添加DaoVoice在线联系 博客加上萌萌的宠物 首页文章只显示预览 从 Hexo 的官网选取主题1.选取主题可以选择喜欢的主题，点击进入到它的 github 地址，只需要把 GitHub 的地址复制下来即可。我选择的主题为：hexo-theme-next，所以下面的配置也会以 next 为例。 2.克隆主题再打开Hexo文件夹下的themes目录（F:\Blog\hexo\themes），右键Git Bash，在命令行输入: git clone https://github.com/theme-next/hexo-theme-next (此处地址替换成你需要使用的主题的地址) 然后等待下载完成 3.修改Hexo配置文件下载完成后，打开Hexo文件夹下的配置文件_config.yml 修改参数为：theme: hexo-theme-next 4.部署主题，本地查看效果返回Hexo目录，右键Git Bash，输入 hexo ghexo s 打开浏览器，输入 http://localhost:4000/ 即可看见更换后的新主题 部署到 Github如果效果满意，就可以将它部署到 Github 上打开 Hexo 文件夹，右键 Git Bash，输入 hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo g -d 查看打开自己的主页，即可看到修改后的效果更多修改效果请查看对应主题的说明文档，点击此查看本主题(Next)对应的说明文档。 进一步美化主题（NexT）根据 NexT 官方文档中的 开始使用 下的流程就可以完成初步的配置 1. 在右上角或者左上角实现 fork me on github效果图如下图所示： 在 GitHub Ribbons 或 GitHub Corners 选择一款你喜欢的挂饰，拷贝方框内的代码： 将刚刚复制的挂饰代码，添加到 Blog/themes/next/layout/_layout.swig 文件中，添加位置如下图所示(放在 &lt;div class=&quot;headband&quot;&gt;&lt;/div&gt; 下方)： 2. 修改文章内链接文本样式修改 Blog/themes/next/source/css/_common/components/post/post.styl ，在末尾添加 CSS 样式：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; //原始链接颜色 border-bottom: none; border-bottom: 1px solid #0593d3; //底部分割线颜色 &amp;:hover &#123; color: #fc6423; //鼠标经过颜色 border-bottom: none; border-bottom: 1px solid #fc6423; //底部分割线颜色 &#125;&#125; 设置后，效果如下： 3. 修改底部标签样式记事本打开 Blog\themes\next\layout\_macro\post.swig 文件command+f 搜索 rel=&quot;tag&quot;&gt;#，将 # 替换成 &lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 4. 在文章末尾添加“文章结束”标记路径 Blog\themes\next\layout\_macro 文件夹中新建 passage-end-tag.swig 文件或者使用以下命令创建：12345//切换到路径_macrocd [_macro路径]//创建passage-end-tag.swig文件touch passage-end-tag.swig 在passage-end-tag.swig添加以下内容，直接用文本编辑器打开，粘贴以下内容后保存 12345&lt;div&gt; &#123;% if not is_index %&#125; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;-------------本文结束 &lt;i class="fa fa-paw"&gt;&lt;/i&gt; 感谢您的阅读-------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 打开 Blog\themes\next\layout\_macro\post.swig，在 post-body 之后， post-footer 之前（post-footer之前两个DIV），添加以下代码： 12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 添加位置如下： 修改主题配置文件_config.yml，在末尾添加： # 文章末尾添加“本文结束”标记 passage_end_tag: enabled: true 配置完成之后，效果如下： 5.设置头像并设置动画效果在 Blog/_config.yml 中添加头像链接地址： //添加头像地址 avatar: [ http://....] 设置头像圆角并旋转，打开 Blog/themes/next/source/css/_common/components/sidebar/sidebar-author.styl，添加以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.site-author-image &#123; display: block; margin: 0 auto; padding: $site-author-image-padding; max-width: $site-author-image-width; height: $site-author-image-height; border: $site-author-image-border-width solid $site-author-image-border-color; /* 头像圆形 */ border-radius: 80px; -webkit-border-radius: 80px; -moz-border-radius: 80px; box-shadow: inset 0 -1px 0 #333sf; /* 设置循环动画 [animation: (play)动画名称 (2s)动画播放时长单位秒或微秒 (ase-out)动画播放的速度曲线为以低速结束 (1s)等待1秒然后开始动画 (1)动画播放次数(infinite为循环播放) ]*/ /* 鼠标经过头像旋转360度 */ -webkit-transition: -webkit-transform 1.0s ease-out; -moz-transition: -moz-transform 1.0s ease-out; transition: transform 1.0s ease-out;&#125;img:hover &#123; /* 鼠标经过停止头像旋转 -webkit-animation-play-state:paused; animation-play-state:paused;*/ /* 鼠标经过头像旋转360度 */ -webkit-transform: rotateZ(360deg); -moz-transform: rotateZ(360deg); transform: rotateZ(360deg);&#125;/* Z 轴旋转动画 */@-webkit-keyframes play &#123; 0% &#123; -webkit-transform: rotateZ(0deg); &#125; 100% &#123; -webkit-transform: rotateZ(-360deg); &#125;&#125;@-moz-keyframes play &#123; 0% &#123; -moz-transform: rotateZ(0deg); &#125; 100% &#123; -moz-transform: rotateZ(-360deg); &#125;&#125;@keyframes play &#123; 0% &#123; transform: rotateZ(0deg); &#125; 100% &#123; transform: rotateZ(-360deg); &#125;&#125; 6.修改代码块自定义样式打开Blog\themes\next\source\css\_custom\custom.styl，添加以下代码： 123456789101112131415// Custom styles.code &#123; color: #ff7600; background: #fbf7f8; margin: 2px;&#125;// 大代码块的自定义样式.highlight, pre &#123; margin: 5px 0; padding: 5px; border-radius: 3px;&#125;.highlight, code, pre &#123; border: 1px solid #d6d6d6;&#125; 7.侧边栏社交小图标设置打开主题配置文件_config.yml，command+f搜索 Social，将你有的社交账号前面的 # 号去掉。格式为： [社交平台名]: [社交地址] || [图标名称] 效果如下：图标可以去Font Awesome Icon网站去找，找到后复制名字到相应的位置即可。 8.主页文章添加阴影效果打开Blog\themes\next\source\css\_custom\custom.styl，添加以下代码： 12345678// 主页文章添加阴影效果 .post &#123; margin-top: 60px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5); &#125; 效果如下： 9.网站底部加上访问量（待完成）10.添加热度（待完成）11.网站底部字数统计和阅读时长打开\themes\next\layout\_partials\footer.swig文件,在copyright前加上画红线这句话： 1&lt;script async src=&quot;https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt; 然后再合适的位置添加显示统计的代码，如图： 12345&lt;div class=&quot;powered-by&quot;&gt;&lt;i class=&quot;fa fa-user-md&quot;&gt;&lt;/i&gt;&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站访客数:&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;/div&gt; 在这里有两中不同计算方式的统计代码： pv的方式，单个用户连续点击n篇文章，记录n次访问量 123&lt;span id=&quot;busuanzi_container_site_pv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; uv的方式，单个用户连续点击n篇文章，只记录1次访客数 123&lt;span id=&quot;busuanzi_container_site_uv&quot;&gt; 本站总访问量&lt;span id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;次&lt;/span&gt; 12.设置网站的图标Favicon在图标网站找一张你喜欢的图标（大：32x32 小：16x16），图标网站：easyicon或者阿里巴巴矢量图标库。将下载下来的小图和中图放在Blog/themes/next/source/images，将默认的两张图片替换掉。 如果你自定义了图片名字，需要修改主题配置文件：123456789# For example, you put your favicons into `hexo-site/source/images` directory.# Then need to rename &amp; redefine they on any other names, otherwise icons from Next will rewrite your custom icons in Hexo.favicon: small: /images/favicon-16x16-next.png //16X16小图 medium: /images/favicon-32x32-next.png //32X32大图 apple_touch_icon: /images/apple-touch-icon-next.png //apple-touch-icon safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml 修改后，效果如下： 13.实现文章统计功能安装 hexo-symbols-count-time，命令如下： npm install hexo-symbols-count-time --save 在站点配置文件 hexo _config.yaml添加：（注意：修改此配置需要重启服务才能更新）12345symbols_count_time: symbols: true # 文章字数 time: true # 阅读时长 total_symbols: true # 所有文章总字数 total_time: true # 所有文章阅读中时长 在主题配置文件 next _config.yaml添加：123456symbols_count_time: separated_meta: true # 是否换行显示 字数统计 及 阅读时长 item_text_post: true # 文章 字数统计 阅读时长 使用图标 还是 文本表示 item_text_total: false # 博客底部统计 字数统计 阅读时长 使用图标 还是 文本表示 awl: 4 wpm: 275 具体可查看 symbols_count_time效果图： 14.添加网页顶部进度加载条编辑主题配置文件，command+F 搜索 pace，将其值改为 ture 就可以了。 15.底部隐藏由Hexo强力驱动、主题–NexT.Mist打开Blog/themes/next/layout/_partials/footer.swig，注释掉相应代码。 16.博文置顶修改hexo-generator-index插件，把node_modules/hexo-generator-index/lib/generator.js中代码替换为： 12345678910111213141516171819202122232425262728&apos;use strict&apos;;var pagination = require(&apos;hexo-pagination&apos;);module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || &apos;page&apos;; return pagination(&apos;&apos;, posts, &#123; perPage: config.index_generator.per_page, layout: [&apos;index&apos;, &apos;archive&apos;], format: paginationDir + &apos;/%d/&apos;, data: &#123; __index: true &#125; &#125;);&#125;; 文章添加Top值，值越大，越靠前： 123456789---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100--- 17.添加站内搜索NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia。下面介绍Local Search的安装。安装 hexo-generator-search npm install hexo-generator-search --save 安装 hexo-generator-searchdb npm install hexo-generator-searchdb --save 编辑站点配置文件，添加以下内容 12345search: path: search.xml field: post format: html limit: 10000 编辑主题配置文件，设置 Local searchenable 为 ture效果如下图所示： 18.在文章底部增加版权信息在目录Blog/themes/next/layout/_macro/，添加文件 my-copyright.swig，内容如下：123456789101112131415161718192021222324252627282930&#123;% if page.copyright %&#125;&lt;div class=&quot;my_post_copyright&quot;&gt; &lt;script src=&quot;//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js&quot;&gt;&lt;/script&gt; &lt;!-- JS库 sweetalert 可修改路径 --&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://unpkg.com/sweetalert/dist/sweetalert.min.js&quot;&gt;&lt;/script&gt; &lt;p&gt;&lt;span&gt;本文标题:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot;&gt;&#123;&#123; page.title &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;文章作者:&lt;/span&gt;&lt;a href=&quot;/&quot; title=&quot;访问 &#123;&#123; theme.author &#125;&#125; 的个人博客&quot;&gt;&#123;&#123; theme.author &#125;&#125;&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;span&gt;发布时间:&lt;/span&gt;&#123;&#123; page.date.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;最后更新:&lt;/span&gt;&#123;&#123; page.updated.format(&quot;YYYY年MM月DD日 - HH:MM&quot;) &#125;&#125;&lt;/p&gt; &lt;p&gt;&lt;span&gt;原始链接:&lt;/span&gt;&lt;a href=&quot;&#123;&#123; url_for(page.path) &#125;&#125;&quot; title=&quot;&#123;&#123; page.title &#125;&#125;&quot;&gt;&#123;&#123; page.permalink &#125;&#125;&lt;/a&gt; &lt;span class=&quot;copy-path&quot; title=&quot;点击复制文章链接&quot;&gt;&lt;i class=&quot;fa fa-clipboard&quot; data-clipboard-text=&quot;&#123;&#123; page.permalink &#125;&#125;&quot; aria-label=&quot;复制成功！&quot;&gt;&lt;/i&gt;&lt;/span&gt; &lt;/p&gt; &lt;p&gt;&lt;span&gt;许可协议:&lt;/span&gt;&lt;i class=&quot;fa fa-creative-commons&quot;&gt;&lt;/i&gt; &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-nd/4.0/&quot; target=&quot;_blank&quot; title=&quot;Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)&quot;&gt;署名-非商业性使用-禁止演绎 4.0 国际&lt;/a&gt; 转载请保留原文链接及作者。&lt;/p&gt; &lt;/div&gt;&lt;script&gt; var clipboard = new Clipboard(&apos;.fa-clipboard&apos;); $(&quot;.fa-clipboard&quot;).click(function()&#123; clipboard.on(&apos;success&apos;, function()&#123; swal(&#123; title: &quot;&quot;, text: &apos;复制成功&apos;, icon: &quot;success&quot;, showConfirmButton: true &#125;); &#125;); &#125;); &lt;/script&gt;&#123;% endif %&#125; 在目录Blog/themes/next/source/css/_common/components/post/下添加文件my-post-copyright.styl，添加以下代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445.my_post_copyright &#123; width: 85%; max-width: 45em; margin: 2.8em auto 0; padding: 0.5em 1.0em; border: 1px solid #d3d3d3; font-size: 0.93rem; line-height: 1.6em; word-break: break-all; background: rgba(255,255,255,0.4);&#125;.my_post_copyright p&#123;margin:0;&#125;.my_post_copyright span &#123; display: inline-block; width: 5.2em; color: #b5b5b5; font-weight: bold;&#125;.my_post_copyright .raw &#123; margin-left: 1em; width: 5em;&#125;.my_post_copyright a &#123; color: #808080; border-bottom:0;&#125;.my_post_copyright a:hover &#123; color: #a3d2a3; text-decoration: underline;&#125;.my_post_copyright:hover .fa-clipboard &#123; color: #000;&#125;.my_post_copyright .post-url:hover &#123; font-weight: normal;&#125;.my_post_copyright .copy-path &#123; margin-left: 1em; width: 1em; +mobile()&#123;display:none;&#125;&#125;.my_post_copyright .copy-path:hover &#123; color: #808080; cursor: pointer;&#125; 修改Blog/themes/next/layout/_macro/post.swig，在如图位置 post body 后面添加以下代码：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'my-copyright.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 在Blog/themes/next/source/css/_common/components/post/post.styl文件最后加入下面的代码： 1@import &quot;my-post-copyright&quot; 在Markdown文章中加入copyright : ture： 12345678910---title: Hexo-NexT主题配置date: 2018-01-20 20:41:08categories: Hexotags:- Hexo- NexTtop: 100copyright: ture--- 配置根目录下的_config.yml文件，配置为： 123456# URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: https://wenmobo.github.io/ //你的网站地址root: /permalink: :year/:month/:day/:title/permalink_defaults: 19.添加侧栏推荐阅读编辑主题配置文件，如下配置即可：12345678# Blog rollslinks_icon: linklinks_title: 推荐阅读#links_layout: blocklinks_layout: inlinelinks: Swift 4: https://developer.apple.com/swift/ Objective-C: https://developer.apple.com/documentation/objectivec 效果如下图所示： 20.添加底部桃心打开Blog/themes/next/layout/_partials/footer.swig搜索with-love，在fontawesom找到你喜欢的图标，在如下位置替换即可：效果如下图所示： 21.添加DaoVoice在线联系首先在DaoVoice注册个账号完成后，会得到一个app_id，后面会用到： 修改themes\hexo-theme-next\layout\_partials\head\head.swig文件，在如下位置添加内容如下： 123456789&#123;% if theme.daovoice %&#125; &lt;script&gt; (function(i,s,o,g,r,a,m)&#123;i[&quot;DaoVoiceObject&quot;]=r;i[r]=i[r]||function()&#123;(i[r].q=i[r].q||[]).push(arguments)&#125;,i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset=&quot;utf-8&quot;;m.parentNode.insertBefore(a,m)&#125;)(window,document,&quot;script&quot;,(&apos;https:&apos; == document.location.protocol ? &apos;https:&apos; : &apos;http:&apos;) + &quot;//widget.daovoice.io/widget/0f81ff2f.js&quot;,&quot;daovoice&quot;) daovoice(&apos;init&apos;, &#123; app_id: &quot;&#123;&#123;theme.daovoice_app_id&#125;&#125;&quot; &#125;); daovoice(&apos;update&apos;); &lt;/script&gt;&#123;% endif %&#125; 在主题配置文件_config.yml文件中添加内容：123# Online contactdaovoice: truedaovoice_app_id: # 这里填你刚才获得的 app_id 聊天窗口配置我的配置如下：效果如下： 22. 博客加上萌萌的宠物然后输入如下代码安装： npm install -save hexo-helper-live2d 然后在 hexo 的 _config.yml 中添加参数：1234567891011live2d: enable: true scriptFrom: local model: use: live2d-widget-model-miku display: position: right width: 140 height: 260 mobile: show: true 其中的 model 可以从一下列表中选择一个：点击查看模型预览，查看官方文档12345678910111213141516171819202122live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16 首页文章只显示预览打开主题配置文件 _config.yml，搜索 auto_excerpt ,找到如下部分： # Automatically Excerpt. Not recommand. # Please use &lt;!-- more --&gt; in the post to control excerpt accurately. auto_excerpt: enable: false length: 150 把enable改为对应的 false 改为 true]]></content>
      <categories>
        <category>未分类</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【线段树】 2018-2019 ICPC,NEERC,Southern Subregional Contest (Online Mirror, ACM-ICPC）C. Cloud Computing]]></title>
    <url>%2Fposts%2Fundefined.html</url>
    <content type="text"><![CDATA[题目链接：http://codeforces.com/contest/1070/problem/CBuber is a Berland technology company that specializes in waste of investor’s money. Recently Buber decided to transfer its infrastructure to a cloud. The company decided to rent CPU cores in the cloud for n consecutive days, which are numbered from 1 to n. Buber requires k CPU cores each day.The cloud provider offers m tariff plans, the i-th tariff plan is characterized by the following parameters:li and ri — the i-th tariff plan is available only on days from li to ri, inclusive,ci — the number of cores per day available for rent on the i-th tariff plan,pi — the price of renting one core per day on the i-th tariff plan.Buber can arbitrarily share its computing core needs between the tariff plans. Every day Buber can rent an arbitrary number of cores (from 0 to ci) on each of the available plans. The number of rented cores on a tariff plan can vary arbitrarily from day to day.Find the minimum amount of money that Buber will pay for its work for n days from 1 to n. If on a day the total number of cores for all available tariff plans is strictly less than k, then this day Buber will have to work on fewer cores (and it rents all the available cores), otherwise Buber rents exactly k cores this day. Description有 n 天，每天需要买 k 个cpu。现在有 m 个供应商，第 i 个供应商可在 [Li, Ri] 天之间，每天提供 Ci 个价格为 Pi 的cpu。如果某天的 cpu 凑不够 k 个，那就把仅有的全买下。问 n 天的最小花费。 Solution对价格建立一棵权值线段树，每个节点表示这个价格区间内的 cpu 数量和总价格。 因此我们对于每一天记录有哪些新活动加入，哪些活动结束。然后维护线段树，即价格为i的活动，一共能提供多少个CPU。 这样对于每天去查询线段树时，就可以找到价格最低的 k 个cpu。在维护线段树时，额外再维护一个当前区间内所有 cpu 的总价格。那么，线段树的每个节点存的是这个价格区间内的 cpu 数量和总价。 这样就利用了线段树的二分性，快速求出了前缀数量和为K的价格和。 Code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;map&gt;#include&lt;set&gt;using namespace std;typedef long long LL;typedef pair&lt;int, int&gt; PII;const int MaxN = 1e6 + 5;const int INF = 0x3f3f3f3f;int n, m, k;vector&lt;PII&gt; day[MaxN];struct sgtree &#123;#define ls o &lt;&lt; 1#define rs ls | 1 LL cnt[4 * MaxN], cost[4 * MaxN]; //当前节点的CPU的 数量 和 总价格 PII val; void pushUP(int o) &#123; cnt[o] = cnt[ls] + cnt[rs]; cost[o] = cost[ls] + cost[rs]; &#125; void update(int o, int l, int r) &#123; if(l == r) &#123; cnt[o] += val.first; cost[o] += 1LL * val.first * val.second; return; &#125; int mid = (l + r) &gt;&gt; 1; if(val.second &lt;= mid) update(ls, l, mid); else update(rs, mid + 1, r); pushUP(o); &#125; LL query(int o, int l, int r, int ned) &#123; if(cnt[o] &lt;= ned) return cost[o]; //当前l~r的总个数小于需要的个数，就全买 if(l == r) return 1LL * ned * l; //查询到最底层后，就全买价格为l的 int mid = (l + r) &gt;&gt; 1; //如果l~mid的个数大于我所需要的，就从此区间选择 if(cnt[ls] &gt;= ned) return query(ls, l, mid, ned); //否则先把便宜的全买了，再去右边的区间查询 return cost[ls] + query(rs, mid+1, r, ned - cnt[ls]); &#125;&#125;tree;int main()&#123; LL ans = 0LL; scanf("%d %d %d", &amp;n, &amp;k, &amp;m); while(m--) &#123; int l, r, c, p; scanf("%d %d %d %d", &amp;l, &amp;r, &amp;c, &amp;p); day[l].push_back(PII(c, p)); //每天新加的活动 day[r+1].push_back(PII(-c, p)); //每天退出的活动 &#125; for(int i = 1; i &lt;= n; i++) &#123; for(int j = 0; j &lt; day[i].size(); j++) &#123; tree.val = day[i][j]; tree.update(1, 1, MaxN); &#125; ans += tree.query(1, 1, MaxN, k); &#125; printf("%lld\n", ans); return 0;&#125;]]></content>
      <categories>
        <category>线段树</category>
      </categories>
      <tags>
        <tag>线段树</tag>
      </tags>
  </entry>
</search>
